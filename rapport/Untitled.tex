%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% LaTeX Template
% Version 1.0 (26/01/16)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[11pt, letterpaper]{article}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[frenchb]{babel}
\usepackage[top=3cm, bottom=3cm, left=2cm, right=2cm]{geometry}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{amsmath}
\usepackage{tabularx}

\newcommand{\hmark}{\rule{\linewidth}{0.5mm}}

\begin{document}
\begin{titlepage}
\pagenumbering{gobble}

\centering

\begin{figure}[t]
\begin{center}
\includegraphics[width=8cm]{upmc.png}
\end{center}
\end{figure}

\hmark \\[0.5cm]
\textsc{\textbf{\Large R\'{e}solution de probl\`{e}mes, g\'{e}n\'{e}ration de mots-crois\'{e}s}} \\[0.5cm]
\textsc{Androide M1 -- RP} \\[0.5cm]
\hmark \\[5cm]

\begin{minipage}{0.4\textwidth}
\begin{flushleft}
Thibault \textsc{Gigant} \\
Laura \textsc{Greige}
\end{flushleft}
\end{minipage}
~
\begin{minipage}{0.4\textwidth}
\begin{flushright}
\emph{Enseignants :}\\[0.5cm]
Patrice \textsc{Perny} \\
Morgan \textsc{Chopin}
\end{flushright}
\end{minipage}\\[4cm]

\large 2015 -- 2016

\end{titlepage}
\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\pagestyle{fancy}
\renewcommand{\headrulewidth}{1pt}
\lhead{\textbf{RP -- R\'{e}solution de probl\`{e}mes, g\'{e}n\'{e}ration de mots-crois\'{e}s}}
\rhead{}

\section*{Introduction}
\addcontentsline{toc}{section}{Introduction}

Dans ce projet, on s'int\'{e}resse \`{a} compl\'{e}ter une grille de taille $M\times N$. Dans un premier temps, on mod\'{e}lisera ce probl\`{e}me comme un probl\`{e}me de satisfaction de contraintes et on d\'{e}veloppera plusieurs m\'{e}thodes diff\'{e}rentes de recherche d'une solution au probl\`{e}me CSP : arc consistance du graphes des contraintes ($AC3$), forward checking ($FC$), conflict back-jumping ($CBJ$). La grille peut \^{e}tre d\'{e}j\`{a} partiellement remplie par l'utilisateur.

Dans un second temps, on mod\'{e}lisera ce probl\`{e}me comme un CSP valu\'{e}. Chaque mot du dictionnaire sera muni d'un poids positif ou nul appartenant à $\left[0,1\right]$ et on d\'{e}veloppera un algorithme de type Branch and Bound qui permette de rechercher la solution optimale qui serait la solution de poids maximal dans la grille.

\section{Mod\'{e}lisation par un CSP et r\'{e}solution}

\subsection{Mod\'{e}lisation}

Pour r\'{e}soudre ce probl\`{e}me, on peut le mod\'{e}liser comme un probl\`{e}me de satisfaction de contraintes en associant une variable \`{a} chaque mot de la grille. Supposons qu'il y ait $m$ mots dans la grille. \bigskip

\begin{description}
	\item[Variables :] ~ $x_{i}~,~\forall i \in \{1,...,m\}$
	
	\bigskip
	
	\item[Domaines :] Soit $dict$ un dictionnaire de mots admissibles:
	
	\begin{align*}
	D(x_{i}) = \{ X \in dict \}
	\end{align*}
	
	\bigskip
	
	\item[Contraintes :]\hspace{0.1cm}\\
	\begin{itemize}
		\item Soit $l_{i}$ la taille du mot en $i$:
		
		\begin{equation} 
		len(x_{i}) = l_{i}
		\end{equation}
		\item Pour tous mots $x_{i}$ et $x_{j}$ qui se croisent \`{a} la \textit{q}-i\`{e}me lettre de $x_{i}$ et \`{a} la \textit{p}-i\`{e}me lettre de $x_{j}$, on a:
		\begin{equation} 
		x_{i}[q] = x_{j}[p]
		\end{equation}
		\item Si l'on ajoute la contrainte suppl\'{e}mentaire qu'un m\^{e}me mot ne peut appara\^{i}tre plus d'une fois dans la grille, il suffit d'ajouter la contrainte \textit{AllDiff}:
		\begin{equation} 
		\textit{AllDiff}~(x_{1},x_{2},...x_{m})
		\end{equation}
	\end{itemize}
\end{description}


\subsection{Exp\'{e}rimentation}

\subsubsection*{Application}

Dans cette section, nous allons tester les performances de nos algorithmes, d'abord en utilisant RAC avec Forward Checking sans AC3 pr\'{e}alable, ensuite RAC avec Forward Checking et AC3 pr\'{e}alable.

\bigskip

\noindent
\begin{tabularx}{\textwidth}{ |X|X|X|X| }
\hline
 & Grille A & Grille B & Grille C  \\
\hline
AC3 & t1 & t2 & t3 \\
\hline 
FC sans AC3 pr\'{e}alable & t1 & t2 & t3  \\
\hline
FC avec AC3 pr\'{e}alable & t1 & t2 & t3  \\
\hline
\end{tabularx}

\subsubsection*{Conflict BackJumping}

\subsubsection*{Applications sur des grilles de tailles plus grandes}

La m\'{e}thode ( ) \'{e}tant la plus efficace, on l'applique sur des instances de grilles de tailles plus grandes.

\bigskip

\noindent
\begin{tabularx}{\textwidth}{ |X|X|X| }
\hline
 & Temps d'\'{e}xecution & \% de solution trouv\'{e}e  \\
\hline
Taille = 10 & t1 & \% \\
\hline 
Taille = 100 & t2 & \%  \\
\hline
\end{tabularx}

\newpage

\section{Extension au cas pond\'{e}r\'{e}}

\subsection{Mod\'{e}lisation}

Dans cette partie, on suppose que chaque mot du dictionnaire est muni d'un poids positif ou nul $\in \left[0,1\right]$ repr\'{e}sentant l'importance qu'un utilisateur attache \`{a} ce mot. Pour trouver la solution optimale du probl\`{e}me, c-\`{a}-d la solution de poids maximum dans la grille, il faut utiliser une m\'{e}thode exacte, comme le \og Branch \& Bound \fg{} qui sera repr\'{e}sent\'{e} par un arbre de recherche binaire.

Chaque sous-probl\`{e}me cr\'{e}\'{e} au cours de l'exploration est d\'{e}sign\'{e} par un n\oe{}ud qui repr\'{e}sente les mots choisis pour chaque variable $x_{i}$ de la grille. Les branches de l'arbre symbolisent le processus de s\'{e}paration, elles repr\'{e}sentent la relation entre les n\oe{}uds (ajout du mot $m_{i} \in D(x_{i}$). Cette m\'{e}thode arborescente nous permettra donc d'\'{e}num\'{e}rer toutes les solutions possibles.

En chacune des feuilles de l'arbre, on a une solution possible qui correspond ou non \`{a} une solution admissible et on retient la meilleure solution obtenue, qui dans ce cas, sera la solution v\'{e}rifiant toutes de poids maximum.\\

Pour am\'{e}liorer la complexit\'{e} du \og Branch \& Bound \fg, seules les solutions qui v\'{e}rifient les contraintes de consistances potentiellement de bonne qualit\'{e} seront \'{e}num\'{e}r\'{e}es, les solutions ne pouvant pas conduire \`{a} am\'{e}liorer la solution courante ne sont pas explor\'{e}es. \\

Le \og Branch \& Bound \fg{} est bas\'{e} sur trois principes :

\subsubsection*{Principe de s\'{e}paration}

Le principe de s\'{e}paration consiste \`{a} diviser le probl\`{e}me en un certain nombre de sous-probl\`{e}mes qui ont chacun leur ensemble de solutions r\'{e}alisables. En r\'{e}solvant tous les sous-probl\`{e}mes et en prenant la meilleure solution trouv\'{e}e, on est assur\'{e} d'avoir r\'{e}solu le probl\`{e}me initial. Ce principe de s\'{e}paration est appliqu\'{e} de mani\`{e}re r\'{e}cursive \`{a} chacun des sous-ensembles tant que celui-ci contient plusieurs solutions. \\
Remarque : La proc\'{e}dure de s\'{e}paration d'un ensemble s'arr\^{e}te lorsqu'une des conditions
suivantes est v\'{e}rifi\'{e}e : \\
-- on sait que l'ensemble ne contient aucune solution admissible (cas o\`{u} les mots ne v\'{e}rifient pas les conditions de consistance) ; \\
-- on conna\^{i}t une solution meilleure que toutes celles de l'ensemble ;

\subsubsection*{Principe d'\'{e}valuation}

Le principe d'\'{e}valuation a pour objectif de conna\^{i}tre la qualit\'{e} des n\oe{}uds \`{a} traiter. La m\'{e}thode de \og Branch and Bound \fg{} utilise deux types de bornes : une borne inf\'{e}rieure de la fonction d'utilit\'{e} du probl\`{e}me initial et une borne sup\'{e}rieure de la fonction d'utilit\'{e}. La connaissance d'une borne inf\'{e}rieure du probl\`{e}me et d'une borne sup\'{e}rieure de la fonction d'utilit\'{e} de chaque sous-probl\`{e}me permet d'arr\^{e}ter  l'exploration d'un sous-ensemble de
solutions qui ne sont pas candidats \`{a} l'optimalit\'{e}.\\
-- borne sup\'{e}rieure:\\
-- borne inf\'{e}rieure:

\subsubsection*{Parcours de l'arbre}

Le type de parcours de l'arbre permet de choisir le prochain n\oe{}ud \`{a} s\'{e}parer parmi l'ensemble des n\oe{}uds de l'arborescence. L'exploration en profondeur privil\'{e}gie les sous-probl\`{e}mes obtenus par le plus grand nombre de s\'{e}parations appliqu\'{e}es au probl\`{e}me de d\'{e}part, c'est-\`{a}-dire aux sommets les plus \'{e}loign\'{e}s de la racine (= de profondeur la plus \'{e}lev\'{e}e). L'obtention rapide d'une solution admissible en est l'avantage.

\subsection{Exp\'{e}rimentation}

\newpage

\textbf{Variables :} ~ $x_{i}~,~\forall i \in \{1,...,m\}$

\bigskip

\textbf{Domaines :} Soit $dict$ un dictionnaire de mots admissibles:

\begin{align*}
D(x_{i}) = \{ X \in dict \}
\end{align*}

\bigskip

\textbf{Contraintes :} Soit $l_{i}$ la taille du mot en $i$:

\begin{equation} 
len(x_{i}) = l_{i}
\end{equation}
\par
Pour tous mots $x_{i}$ et $x_{j}$ qui se croisent \`{a} la \textit{q}-i\`{e}me lettre de $x_{i}$ et \`{a} la \textit{p}-i\`{e}me lettre de $x_{j}$, on a:
\begin{equation} 
x_{i}[q] = x_{j}[p]
\end{equation}
\par
Si l'on ajoute la contrainte suppl\'{e}mentaire qu'un m\^{e}me mot ne peut appara\^{i}tre plus d'une fois dans la grille, il suffit d'ajouter la contrainte \textit{AllDiff}:
\begin{equation} 
\textit{AllDiff}~(x_{1},x_{2},...x_{m})
\end{equation}

\subsection{Exp\'{e}rimentation}

\subsection{Bonus}

\newpage

\section*{Conclusion}
\addcontentsline{toc}{section}{Conclusion}

\end{document}